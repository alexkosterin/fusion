#!/bin/python

import sys, os, re, getopt, string, datetime

## pre-compiled regexps ########################################################

rx_dfile_skip_line = re.compile(r"^(\s*[;#].*|\s*)$")
rx_dfile_statment = re.compile(r"^\s*([_a-zA-Z0-9~!@#$%&\[\]\-\+\.\;]+)\s*:?\s*(profile\s*=\s*([_a-zA-Z][_a-zA-Z0-9]*))?\s*oflags\s*=\s*([rR]?[wW]?)(\s*(callback\s*=\s*([_a-zA-Z][_a-zA-Z0-9]*)))?(\s*desc\s*=\s*(\"[^\"]*\"))?\s*([;#].*)?$")

## code templates ##############################################################

COPYRIGHT_HEADER = """\
/*
 *  FUSION
 *  Copyright (c) 2013-2014 Alex Kosterin
 */
"""

AUTOGENERTED_WARNING = """
/*
 * This is automatically generated file.
 * Do not edit this file, or your changes will be lost!
 * Command: "$COMMAND$"
 * Date: $DATETIME$
 */
"""

HEADER_TEMPLATE = COPYRIGHT_HEADER + AUTOGENERTED_WARNING + """
#ifndef $FILE_NAME$__H
#define $FILE_NAME$__H

#include "$INCLUDE$"

enum {
$TAG_IDS$};

struct $TYPE_NAME$ : tags_helper_t {
  $TYPE_NAME$(nf::client_t&);
};

#endif  //$FILE_NAME$__H
"""

HEADER_NS_TEMPLATE = COPYRIGHT_HEADER + AUTOGENERTED_WARNING + """
#ifndef $FILE_NAME$__H
#define $FILE_NAME$__H

#include "$INCLUDE$"

namespace $NAMESPACE_NAME$ {
enum {
$TAG_IDS$};

struct $TYPE_NAME$ : tags_helper_t {
	$TYPE_NAME$(nf::client_t&);
};
};	// $NAMESPACE_NAME$

#endif  //$FILE_NAME$__H
"""

CPP_TEMPLATE = COPYRIGHT_HEADER + AUTOGENERTED_WARNING + """
#include "$FILE_NAME$.h"

$CALLBACK_EXTERNS$
static tag_entry_t __tags[] = {
$TAG_ENTRIES$};

$TYPE_NAME$::$TYPE_NAME$(nf::client_t& client) : tags_helper_t(client, sizeof(__tags)/sizeof(__tags[0]), __tags) {};

"""

CPP_NS_TEMPLATE = COPYRIGHT_HEADER + AUTOGENERTED_WARNING + """
#include "$FILE_NAME$.h"

$CALLBACK_EXTERNS$
namespace $NAMESPACE_NAME$ {
static tag_entry_t __tags[] = {
$TAG_ENTRIES$};

$TYPE_NAME$::$TYPE_NAME$(nf::client_t& client) : tags_helper_t(client, sizeof(__tags)/sizeof(__tags[0]), __tags) {};
};	// $NAMESPACE_NAME$

"""

class tag: #####################################################################
	__slots__ = ('oflags', 'cb', 'desc', 'processed')

	def __init__(self, oflags, cb, desc):
		self.oflags			= oflags
		self.cb					= cb
		self.desc				= desc if desc else "NULL"
		self.processed	= 0

	def __str__(self):
		return ('oflags=%s cb=%s desc=%s processed=%d') % (self.oflags, self.cb, self.desc, self.processed)

def t2sym(c):  ###################################################################
	if int(c) == 0:
		return "nf::MT_EVENT"
	elif int(c) == 8:
		return "nf::MT_PERSISTENT|nf::MT_EVENT"
	else:
		return "ERROR"

def of2sym(c):  ###################################################################
	if c == 'r':
		return "nf::O_RDONLY"
	elif c == 'w':
		return "nf::O_WRONLY"
	elif c == 'rw':
		return "nf::O_RDWR"
	elif c == 'R':
		return "nf::O_EXCL|nf::O_RDONLY"
	elif c == 'W':
		return "nf::O_EXCL|nf::O_WRONLY"
	else:
		print >> sys.stderr, "Error: Invalid or not supported oflag='%s'" % c
		sys.exit(1)

def usage():  ##################################################################
	print >> sys.stderr, """Generate Fusion tags helper file. (c) Alx Kosterin 2013-2014
csv2c [-o output] -p profile -d input-definitin-file [-f c-file-name-base] [-n namespace] [input-csv-file]
  -h, --help       Print help and exit.
  -i, --include    Include path to tags_helper.h
  -d, --deffile    Input definition file.
  -f, --filename   <filename>.h <filename>.cpp
  -n, --namespace  Use namespace, if empty do not use namespaces.
  -o, --output     Output file base name: name.h, name.cpp, optional. Default is profile name.
  -p, --profile    Profile to use.
  -t, --typename   Use this typename for...
"""

def main(): ####################################################################
	try:
		opts, args = getopt.getopt(sys.argv[1:], "i:d:f:n:o:p:t:h", ["help", "include=", "deffile=", "filename=", "namespace=", "profile=", "output=", "typename="])
	except getopt.GetoptError as err:
		print >> sys.stderr, str(err)
		usage()
		sys.exit(2)

	opt_output_base_name	= '';
	opt_profile						= '';
	opt_filename					= None;
	opt_namespace					= None
	opt_typename					= None
	opt_helper_include		= 'tags_helper.h'

	def_file = None
	csv_file = None
	tags = {}
	cbs  = {}

	## parse arguments ##
	for o, a in opts:
		if o in ("-h", "--help"):
			usage()
			sys.exit()
		elif o in ("-i", "--include"):
			opt_helper_include = a
		elif o in ("-d", "--deffile"):
			def_file = open(a, 'r')
		elif o in ("-f", "--filename"):
			opt_filename = a
		elif o in ("-n", "--namespace"):
			opt_namespace = a
		elif o in ("-o", "--output"):
			output = opt_output_base_name
		elif o in ("-p", "--profile"):
			opt_profile = a
		elif o in ("-t", "--typename"):
			opt_typename = a

	if len(args) == 0:
		csv_file	= sys.stdin
	elif len(args) == 1:
		 csv_file = open(args[0], 'r')
	else:
		print >> sys.stderr, "Error: Too many inputs '%s'. Expect at most one." % args
		exit(1)

	if not def_file:
		print >> sys.stderr, "Error: No definition file given. Expect one." % args
		exit(1)

	if not opt_profile:
		print >> sys.stderr, "Error: No profile given. Expect one." % args
		exit(1)

	if not opt_output_base_name:
		opt_output_base_name = opt_profile

	if not opt_filename:
		basefilename	= filename = opt_profile
	else:
		filename			= opt_filename
		basefilename	= opt_filename.rsplit("/")[-1]

	if not opt_typename:
		typename = "%s_t" % opt_profile
	else:
		typename = opt_typename

	## process definition file ##
	for s in def_file:
		if rx_dfile_skip_line.match(s): continue

		m = rx_dfile_statment.match(s)
		if not m:
			print >> sys.stderr, "Error: Bad syntax '%s'." % s.rstrip('\r\n')
			exit(1)

		if tags.has_key(m.group(1)):
			print >> sys.stderr, "Error: Duplicate entry '%s' in '%s' file." % (m.group(1), def_file.name)
			exit(1)

		t = tags[m.group(1)] = tag(
			m.group(4),
			m.group(7),
			m.group(9))

		if m.group(7): cbs[m.group(7)] = None;

	## process csv file ##
	lines = csv_file.readlines()

	header = lines[0].rstrip('\r\n').split(',')

	if (len(lines) == 0) or (not opt_profile in header):
		print >> sys.stderr, "Error: Cannot find profile '%s' in '%s' file: '%s'." % (opt_profile, csv_file.name, header)
		exit(1)

	sidx = header.index("size:")
	tidx = header.index("type:")
	pidx = header.index(opt_profile)
	didx = fidx = uidx = None

	try:	didx = header.index("desc:")
	except:	pass

	try:	fidx = header.index("format:")
	except:	pass

	try:	uidx = header.index("units:")
	except:	pass

#	print "pidx=%d sidx=%d, tidx=%d, didx=%r" % (pidx, sidx, tidx, didx)

	tag_entries = ''
	tag_ids     = ''
	tag_cbs     = ''
	trans       = string.maketrans("~!%#$^?&()[] ", "_____________")

	i = 0
	for s in lines[1:]:
		items = s.rstrip('\r\n').split(',')
		name   = items[pidx]

		if name in tags.keys():
			if tags[name].processed:
				print >> sys.stderr, "Error: Multiple definitions for '%s' in '%s' file." % (name, csv_file.name)
				exit(1)
			else:
				tags[name].processed = 1

			tag_entries += "	{ \"%s\",\t%s,\t%d,\t%s,\t%s,\t%s,\t},\n" % (
				name,
				t2sym(items[tidx]),
				int(items[sidx]),
				of2sym(tags[name].oflags),
				tags[name].cb if tags[name].cb else "NULL",
				"\"" + items[didx] + "\"" if didx and items[didx] else tags[name].desc)

			tag_ids += "	%s	= %d,\n" % (name.translate(trans).upper(), i);
			i += 1

	unprocessed = False

	for name in tags.keys():
		if not tags[name].processed:
			unprocessed = True
			print >> sys.stderr, "Error: Tag %s not found." % name

	if unprocessed:
		print >> sys.stderr, "Exiting..."
		exit(1)

	for cb in cbs.keys():
		tag_cbs += "nf::result_t __stdcall %s(nf::mid_t, size_t, const void*);\n" % cb;

#	print 'tag_cbs =', tag_cbs

	s = HEADER_NS_TEMPLATE if opt_namespace else HEADER_TEMPLATE
	s = s.replace('$COMMAND$',   " ".join(sys.argv))
	s = s.replace('$DATETIME$',  datetime.datetime.now().isoformat(' '))
	s = s.replace('$INCLUDE$',   opt_helper_include)
	s = s.replace('$FILE_NAME$', basefilename)
	s = s.replace('$TYPE_NAME$', typename)
	s = s.replace('$TAG_IDS$',   tag_ids)
	if opt_namespace: s = s.replace('$NAMESPACE_NAME$', opt_namespace)

	f = open("%s.h" % filename, 'w')
	f.write(s)

	s = CPP_NS_TEMPLATE if opt_namespace else CPP_TEMPLATE
	s = s.replace('$COMMAND$',   " ".join(sys.argv))
	s = s.replace('$DATETIME$',  datetime.datetime.now().isoformat(' '))
	s = s.replace('$FILE_NAME$', basefilename)
	s = s.replace('$TYPE_NAME$', typename)
	s = s.replace('$TAG_ENTRIES$', tag_entries)
	s = s.replace('$CALLBACK_EXTERNS$', tag_cbs)
	if opt_namespace: s = s.replace('$NAMESPACE_NAME$', opt_namespace)

	f = open("%s.cpp" % filename, 'w')
	f.write(s)

if __name__ == "__main__":
	main()

