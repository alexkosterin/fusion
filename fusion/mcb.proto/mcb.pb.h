// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mcb.proto

#ifndef PROTOBUF_mcb_2eproto__INCLUDED
#define PROTOBUF_mcb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_mcb_2eproto();
void protobuf_AssignDesc_mcb_2eproto();
void protobuf_ShutdownFile_mcb_2eproto();

class mcb_reg;
class mcb_subscribe;
class mcb_mreg;
class mcb_mopen_req;
class mcb_mopen_rep;
class mcb_mlink;
class mcb_munlink;
class mcb_mmove;
class mcb_mlist_req;
class mcb_mlist_rep;
class mcb_mstat;
class mcb_mattr_read;
class mcb_mattr_write;
class mcb_mattrs_read;
class mcb_msave;
class mcb_mload;
class mcb_sysinfo_request;
class mcb_sysinfo_common;
class mcb_sysinfo_client;
class mcb_sysinfo_message;
class mcb_sysinfo_reply;

enum MCB_SYSINFO_FLAGS {
  SYS_CLIENTS = 1,
  SYS_MESSAGES = 2,
  SYS_CLIENT_MESSAGES = 4,
  COM_START_TIME = 8,
  COM_AVAIL_MCBS = 16,
  COM_ALLOCATED_MCBS = 32,
  COM_PREALLOC_MCBS = 64,
  COM_MAX_ALLOC_MCBS = 128,
  CLI_NAME = 256,
  CLI_UUID = 512,
  CLI_ADDRESS = 1024,
  CLI_DEFAULT_PROFILE = 2048,
  CLI_PROFILES = 4096,
  CLI_GROUPS = 8192,
  CLI_START_TIME = 16384,
  CLI_SYNC_PERIOD = 32768,
  CLI_CONN_LATENCY = 65536,
  CLI_QUEUE_LIMIT = 131072,
  CLI_QUEUE_SIZE = 262144,
  MSG_NAME = 524288,
  MSG_PATH = 1048576,
  MSG_OFLAG = 2097152,
  MSG_SFLAG = 4194304,
  MSG_OPEN_NR = 8388608,
  MSG_SUBS_NR = 16777216,
  MSG_SND_NR = 33554432,
  MSG_RCV_NR = 67108864,
  MSG_SND_AVG = 134217728,
  MSG_RCV_AVG = 268435456
};
bool MCB_SYSINFO_FLAGS_IsValid(int value);
const MCB_SYSINFO_FLAGS MCB_SYSINFO_FLAGS_MIN = SYS_CLIENTS;
const MCB_SYSINFO_FLAGS MCB_SYSINFO_FLAGS_MAX = MSG_RCV_AVG;
const int MCB_SYSINFO_FLAGS_ARRAYSIZE = MCB_SYSINFO_FLAGS_MAX + 1;

const ::google::protobuf::EnumDescriptor* MCB_SYSINFO_FLAGS_descriptor();
inline const ::std::string& MCB_SYSINFO_FLAGS_Name(MCB_SYSINFO_FLAGS value) {
  return ::google::protobuf::internal::NameOfEnum(
    MCB_SYSINFO_FLAGS_descriptor(), value);
}
inline bool MCB_SYSINFO_FLAGS_Parse(
    const ::std::string& name, MCB_SYSINFO_FLAGS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MCB_SYSINFO_FLAGS>(
    MCB_SYSINFO_FLAGS_descriptor(), name, value);
}
// ===================================================================

class mcb_reg : public ::google::protobuf::Message {
 public:
  mcb_reg();
  virtual ~mcb_reg();

  mcb_reg(const mcb_reg& from);

  inline mcb_reg& operator=(const mcb_reg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_reg& default_instance();

  void Swap(mcb_reg* other);

  // implements Message ----------------------------------------------

  mcb_reg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_reg& from);
  void MergeFrom(const mcb_reg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 ver_maj = 1;
  inline bool has_ver_maj() const;
  inline void clear_ver_maj();
  static const int kVerMajFieldNumber = 1;
  inline ::google::protobuf::uint32 ver_maj() const;
  inline void set_ver_maj(::google::protobuf::uint32 value);

  // required uint32 ver_min = 2;
  inline bool has_ver_min() const;
  inline void clear_ver_min();
  static const int kVerMinFieldNumber = 2;
  inline ::google::protobuf::uint32 ver_min() const;
  inline void set_ver_min(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated string profile = 4;
  inline int profile_size() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 4;
  inline const ::std::string& profile(int index) const;
  inline ::std::string* mutable_profile(int index);
  inline void set_profile(int index, const ::std::string& value);
  inline void set_profile(int index, const char* value);
  inline void set_profile(int index, const char* value, size_t size);
  inline ::std::string* add_profile();
  inline void add_profile(const ::std::string& value);
  inline void add_profile(const char* value);
  inline void add_profile(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& profile() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_profile();

  // optional bytes uuid = 5;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 5;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string pswd = 6;
  inline bool has_pswd() const;
  inline void clear_pswd();
  static const int kPswdFieldNumber = 6;
  inline const ::std::string& pswd() const;
  inline void set_pswd(const ::std::string& value);
  inline void set_pswd(const char* value);
  inline void set_pswd(const char* value, size_t size);
  inline ::std::string* mutable_pswd();
  inline ::std::string* release_pswd();
  inline void set_allocated_pswd(::std::string* pswd);

  // @@protoc_insertion_point(class_scope:mcb_reg)
 private:
  inline void set_has_ver_maj();
  inline void clear_has_ver_maj();
  inline void set_has_ver_min();
  inline void clear_has_ver_min();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_pswd();
  inline void clear_has_pswd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 ver_maj_;
  ::google::protobuf::uint32 ver_min_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> profile_;
  ::std::string* uuid_;
  ::std::string* pswd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_reg* default_instance_;
};
// -------------------------------------------------------------------

class mcb_subscribe : public ::google::protobuf::Message {
 public:
  mcb_subscribe();
  virtual ~mcb_subscribe();

  mcb_subscribe(const mcb_subscribe& from);

  inline mcb_subscribe& operator=(const mcb_subscribe& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_subscribe& default_instance();

  void Swap(mcb_subscribe* other);

  // implements Message ----------------------------------------------

  mcb_subscribe* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_subscribe& from);
  void MergeFrom(const mcb_subscribe& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::uint32 mid() const;
  inline void set_mid(::google::protobuf::uint32 value);

  // required uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mcb_subscribe)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mid_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_subscribe* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mreg : public ::google::protobuf::Message {
 public:
  mcb_mreg();
  virtual ~mcb_mreg();

  mcb_mreg(const mcb_mreg& from);

  inline mcb_mreg& operator=(const mcb_mreg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mreg& default_instance();

  void Swap(mcb_mreg* other);

  // implements Message ----------------------------------------------

  mcb_mreg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mreg& from);
  void MergeFrom(const mcb_mreg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required uint32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // required uint32 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint32 gid() const;
  inline void set_gid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mcb_mreg)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* user_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mreg* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mopen_req : public ::google::protobuf::Message {
 public:
  mcb_mopen_req();
  virtual ~mcb_mopen_req();

  mcb_mopen_req(const mcb_mopen_req& from);

  inline mcb_mopen_req& operator=(const mcb_mopen_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mopen_req& default_instance();

  void Swap(mcb_mopen_req* other);

  // implements Message ----------------------------------------------

  mcb_mopen_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mopen_req& from);
  void MergeFrom(const mcb_mopen_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 size = 4;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 4;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional bytes data = 5;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 5;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:mcb_mopen_req)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 type_;
  ::std::string* data_;
  ::google::protobuf::uint32 size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mopen_req* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mopen_rep : public ::google::protobuf::Message {
 public:
  mcb_mopen_rep();
  virtual ~mcb_mopen_rep();

  mcb_mopen_rep(const mcb_mopen_rep& from);

  inline mcb_mopen_rep& operator=(const mcb_mopen_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mopen_rep& default_instance();

  void Swap(mcb_mopen_rep* other);

  // implements Message ----------------------------------------------

  mcb_mopen_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mopen_rep& from);
  void MergeFrom(const mcb_mopen_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::uint32 mid() const;
  inline void set_mid(::google::protobuf::uint32 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 size = 3;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 3;
  inline ::google::protobuf::uint32 size() const;
  inline void set_size(::google::protobuf::uint32 value);

  // optional bool already_opened = 4;
  inline bool has_already_opened() const;
  inline void clear_already_opened();
  static const int kAlreadyOpenedFieldNumber = 4;
  inline bool already_opened() const;
  inline void set_already_opened(bool value);

  // @@protoc_insertion_point(class_scope:mcb_mopen_rep)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_already_opened();
  inline void clear_has_already_opened();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mid_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 size_;
  bool already_opened_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mopen_rep* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mlink : public ::google::protobuf::Message {
 public:
  mcb_mlink();
  virtual ~mcb_mlink();

  mcb_mlink(const mcb_mlink& from);

  inline mcb_mlink& operator=(const mcb_mlink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mlink& default_instance();

  void Swap(mcb_mlink* other);

  // implements Message ----------------------------------------------

  mcb_mlink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mlink& from);
  void MergeFrom(const mcb_mlink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string link = 1;
  inline bool has_link() const;
  inline void clear_link();
  static const int kLinkFieldNumber = 1;
  inline const ::std::string& link() const;
  inline void set_link(const ::std::string& value);
  inline void set_link(const char* value);
  inline void set_link(const char* value, size_t size);
  inline ::std::string* mutable_link();
  inline ::std::string* release_link();
  inline void set_allocated_link(::std::string* link);

  // required string orig = 2;
  inline bool has_orig() const;
  inline void clear_orig();
  static const int kOrigFieldNumber = 2;
  inline const ::std::string& orig() const;
  inline void set_orig(const ::std::string& value);
  inline void set_orig(const char* value);
  inline void set_orig(const char* value, size_t size);
  inline ::std::string* mutable_orig();
  inline ::std::string* release_orig();
  inline void set_allocated_orig(::std::string* orig);

  // required bool soft = 3;
  inline bool has_soft() const;
  inline void clear_soft();
  static const int kSoftFieldNumber = 3;
  inline bool soft() const;
  inline void set_soft(bool value);

  // @@protoc_insertion_point(class_scope:mcb_mlink)
 private:
  inline void set_has_link();
  inline void clear_has_link();
  inline void set_has_orig();
  inline void clear_has_orig();
  inline void set_has_soft();
  inline void clear_has_soft();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* link_;
  ::std::string* orig_;
  bool soft_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mlink* default_instance_;
};
// -------------------------------------------------------------------

class mcb_munlink : public ::google::protobuf::Message {
 public:
  mcb_munlink();
  virtual ~mcb_munlink();

  mcb_munlink(const mcb_munlink& from);

  inline mcb_munlink& operator=(const mcb_munlink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_munlink& default_instance();

  void Swap(mcb_munlink* other);

  // implements Message ----------------------------------------------

  mcb_munlink* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_munlink& from);
  void MergeFrom(const mcb_munlink& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:mcb_munlink)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_munlink* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mmove : public ::google::protobuf::Message {
 public:
  mcb_mmove();
  virtual ~mcb_mmove();

  mcb_mmove(const mcb_mmove& from);

  inline mcb_mmove& operator=(const mcb_mmove& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mmove& default_instance();

  void Swap(mcb_mmove* other);

  // implements Message ----------------------------------------------

  mcb_mmove* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mmove& from);
  void MergeFrom(const mcb_mmove& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string from = 1;
  inline bool has_from() const;
  inline void clear_from();
  static const int kFromFieldNumber = 1;
  inline const ::std::string& from() const;
  inline void set_from(const ::std::string& value);
  inline void set_from(const char* value);
  inline void set_from(const char* value, size_t size);
  inline ::std::string* mutable_from();
  inline ::std::string* release_from();
  inline void set_allocated_from(::std::string* from);

  // required string to = 2;
  inline bool has_to() const;
  inline void clear_to();
  static const int kToFieldNumber = 2;
  inline const ::std::string& to() const;
  inline void set_to(const ::std::string& value);
  inline void set_to(const char* value);
  inline void set_to(const char* value, size_t size);
  inline ::std::string* mutable_to();
  inline ::std::string* release_to();
  inline void set_allocated_to(::std::string* to);

  // @@protoc_insertion_point(class_scope:mcb_mmove)
 private:
  inline void set_has_from();
  inline void clear_has_from();
  inline void set_has_to();
  inline void clear_has_to();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* from_;
  ::std::string* to_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mmove* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mlist_req : public ::google::protobuf::Message {
 public:
  mcb_mlist_req();
  virtual ~mcb_mlist_req();

  mcb_mlist_req(const mcb_mlist_req& from);

  inline mcb_mlist_req& operator=(const mcb_mlist_req& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mlist_req& default_instance();

  void Swap(mcb_mlist_req* other);

  // implements Message ----------------------------------------------

  mcb_mlist_req* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mlist_req& from);
  void MergeFrom(const mcb_mlist_req& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string mask = 1;
  inline bool has_mask() const;
  inline void clear_mask();
  static const int kMaskFieldNumber = 1;
  inline const ::std::string& mask() const;
  inline void set_mask(const ::std::string& value);
  inline void set_mask(const char* value);
  inline void set_mask(const char* value, size_t size);
  inline ::std::string* mutable_mask();
  inline ::std::string* release_mask();
  inline void set_allocated_mask(::std::string* mask);

  // optional uint32 flags = 2;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional string profile = 3;
  inline bool has_profile() const;
  inline void clear_profile();
  static const int kProfileFieldNumber = 3;
  inline const ::std::string& profile() const;
  inline void set_profile(const ::std::string& value);
  inline void set_profile(const char* value);
  inline void set_profile(const char* value, size_t size);
  inline ::std::string* mutable_profile();
  inline ::std::string* release_profile();
  inline void set_allocated_profile(::std::string* profile);

  // @@protoc_insertion_point(class_scope:mcb_mlist_req)
 private:
  inline void set_has_mask();
  inline void clear_has_mask();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_profile();
  inline void clear_has_profile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* mask_;
  ::std::string* profile_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mlist_req* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mlist_rep : public ::google::protobuf::Message {
 public:
  mcb_mlist_rep();
  virtual ~mcb_mlist_rep();

  mcb_mlist_rep(const mcb_mlist_rep& from);

  inline mcb_mlist_rep& operator=(const mcb_mlist_rep& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mlist_rep& default_instance();

  void Swap(mcb_mlist_rep* other);

  // implements Message ----------------------------------------------

  mcb_mlist_rep* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mlist_rep& from);
  void MergeFrom(const mcb_mlist_rep& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:mcb_mlist_rep)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> names_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mlist_rep* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mstat : public ::google::protobuf::Message {
 public:
  mcb_mstat();
  virtual ~mcb_mstat();

  mcb_mstat(const mcb_mstat& from);

  inline mcb_mstat& operator=(const mcb_mstat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mstat& default_instance();

  void Swap(mcb_mstat* other);

  // implements Message ----------------------------------------------

  mcb_mstat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mstat& from);
  void MergeFrom(const mcb_mstat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 st_mid = 1;
  inline bool has_st_mid() const;
  inline void clear_st_mid();
  static const int kStMidFieldNumber = 1;
  inline ::google::protobuf::uint32 st_mid() const;
  inline void set_st_mid(::google::protobuf::uint32 value);

  // required uint32 st_type = 2;
  inline bool has_st_type() const;
  inline void clear_st_type();
  static const int kStTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 st_type() const;
  inline void set_st_type(::google::protobuf::uint32 value);

  // required uint32 st_nlink = 3;
  inline bool has_st_nlink() const;
  inline void clear_st_nlink();
  static const int kStNlinkFieldNumber = 3;
  inline ::google::protobuf::uint32 st_nlink() const;
  inline void set_st_nlink(::google::protobuf::uint32 value);

  // required uint32 st_uid = 4;
  inline bool has_st_uid() const;
  inline void clear_st_uid();
  static const int kStUidFieldNumber = 4;
  inline ::google::protobuf::uint32 st_uid() const;
  inline void set_st_uid(::google::protobuf::uint32 value);

  // required uint32 st_gid = 5;
  inline bool has_st_gid() const;
  inline void clear_st_gid();
  static const int kStGidFieldNumber = 5;
  inline ::google::protobuf::uint32 st_gid() const;
  inline void set_st_gid(::google::protobuf::uint32 value);

  // required uint32 st_size = 6;
  inline bool has_st_size() const;
  inline void clear_st_size();
  static const int kStSizeFieldNumber = 6;
  inline ::google::protobuf::uint32 st_size() const;
  inline void set_st_size(::google::protobuf::uint32 value);

  // required uint32 st_atime = 7;
  inline bool has_st_atime() const;
  inline void clear_st_atime();
  static const int kStAtimeFieldNumber = 7;
  inline ::google::protobuf::uint32 st_atime() const;
  inline void set_st_atime(::google::protobuf::uint32 value);

  // required uint32 st_mtime = 8;
  inline bool has_st_mtime() const;
  inline void clear_st_mtime();
  static const int kStMtimeFieldNumber = 8;
  inline ::google::protobuf::uint32 st_mtime() const;
  inline void set_st_mtime(::google::protobuf::uint32 value);

  // required uint64 st_ctime = 9;
  inline bool has_st_ctime() const;
  inline void clear_st_ctime();
  static const int kStCtimeFieldNumber = 9;
  inline ::google::protobuf::uint64 st_ctime() const;
  inline void set_st_ctime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:mcb_mstat)
 private:
  inline void set_has_st_mid();
  inline void clear_has_st_mid();
  inline void set_has_st_type();
  inline void clear_has_st_type();
  inline void set_has_st_nlink();
  inline void clear_has_st_nlink();
  inline void set_has_st_uid();
  inline void clear_has_st_uid();
  inline void set_has_st_gid();
  inline void clear_has_st_gid();
  inline void set_has_st_size();
  inline void clear_has_st_size();
  inline void set_has_st_atime();
  inline void clear_has_st_atime();
  inline void set_has_st_mtime();
  inline void clear_has_st_mtime();
  inline void set_has_st_ctime();
  inline void clear_has_st_ctime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 st_mid_;
  ::google::protobuf::uint32 st_type_;
  ::google::protobuf::uint32 st_nlink_;
  ::google::protobuf::uint32 st_uid_;
  ::google::protobuf::uint32 st_gid_;
  ::google::protobuf::uint32 st_size_;
  ::google::protobuf::uint32 st_atime_;
  ::google::protobuf::uint32 st_mtime_;
  ::google::protobuf::uint64 st_ctime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mstat* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mattr_read : public ::google::protobuf::Message {
 public:
  mcb_mattr_read();
  virtual ~mcb_mattr_read();

  mcb_mattr_read(const mcb_mattr_read& from);

  inline mcb_mattr_read& operator=(const mcb_mattr_read& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mattr_read& default_instance();

  void Swap(mcb_mattr_read* other);

  // implements Message ----------------------------------------------

  mcb_mattr_read* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mattr_read& from);
  void MergeFrom(const mcb_mattr_read& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::uint32 mid() const;
  inline void set_mid(::google::protobuf::uint32 value);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required uint32 len = 3;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 3;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mcb_mattr_read)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_len();
  inline void clear_has_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::uint32 mid_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mattr_read* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mattr_write : public ::google::protobuf::Message {
 public:
  mcb_mattr_write();
  virtual ~mcb_mattr_write();

  mcb_mattr_write(const mcb_mattr_write& from);

  inline mcb_mattr_write& operator=(const mcb_mattr_write& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mattr_write& default_instance();

  void Swap(mcb_mattr_write* other);

  // implements Message ----------------------------------------------

  mcb_mattr_write* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mattr_write& from);
  void MergeFrom(const mcb_mattr_write& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::uint32 mid() const;
  inline void set_mid(::google::protobuf::uint32 value);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:mcb_mattr_write)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;
  ::google::protobuf::uint32 mid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mattr_write* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mattrs_read : public ::google::protobuf::Message {
 public:
  mcb_mattrs_read();
  virtual ~mcb_mattrs_read();

  mcb_mattrs_read(const mcb_mattrs_read& from);

  inline mcb_mattrs_read& operator=(const mcb_mattrs_read& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mattrs_read& default_instance();

  void Swap(mcb_mattrs_read* other);

  // implements Message ----------------------------------------------

  mcb_mattrs_read* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mattrs_read& from);
  void MergeFrom(const mcb_mattrs_read& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::uint32 mid() const;
  inline void set_mid(::google::protobuf::uint32 value);

  // required uint32 len = 2;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 2;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:mcb_mattrs_read)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_len();
  inline void clear_has_len();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 mid_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mattrs_read* default_instance_;
};
// -------------------------------------------------------------------

class mcb_msave : public ::google::protobuf::Message {
 public:
  mcb_msave();
  virtual ~mcb_msave();

  mcb_msave(const mcb_msave& from);

  inline mcb_msave& operator=(const mcb_msave& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_msave& default_instance();

  void Swap(mcb_msave* other);

  // implements Message ----------------------------------------------

  mcb_msave* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_msave& from);
  void MergeFrom(const mcb_msave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 len = 1;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 1;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // required string sep = 2;
  inline bool has_sep() const;
  inline void clear_sep();
  static const int kSepFieldNumber = 2;
  inline const ::std::string& sep() const;
  inline void set_sep(const ::std::string& value);
  inline void set_sep(const char* value);
  inline void set_sep(const char* value, size_t size);
  inline ::std::string* mutable_sep();
  inline ::std::string* release_sep();
  inline void set_allocated_sep(::std::string* sep);

  // @@protoc_insertion_point(class_scope:mcb_msave)
 private:
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_sep();
  inline void clear_has_sep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sep_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_msave* default_instance_;
};
// -------------------------------------------------------------------

class mcb_mload : public ::google::protobuf::Message {
 public:
  mcb_mload();
  virtual ~mcb_mload();

  mcb_mload(const mcb_mload& from);

  inline mcb_mload& operator=(const mcb_mload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_mload& default_instance();

  void Swap(mcb_mload* other);

  // implements Message ----------------------------------------------

  mcb_mload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_mload& from);
  void MergeFrom(const mcb_mload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // required string sep = 2;
  inline bool has_sep() const;
  inline void clear_sep();
  static const int kSepFieldNumber = 2;
  inline const ::std::string& sep() const;
  inline void set_sep(const ::std::string& value);
  inline void set_sep(const char* value);
  inline void set_sep(const char* value, size_t size);
  inline ::std::string* mutable_sep();
  inline ::std::string* release_sep();
  inline void set_allocated_sep(::std::string* sep);

  // @@protoc_insertion_point(class_scope:mcb_mload)
 private:
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_sep();
  inline void clear_has_sep();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* text_;
  ::std::string* sep_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_mload* default_instance_;
};
// -------------------------------------------------------------------

class mcb_sysinfo_request : public ::google::protobuf::Message {
 public:
  mcb_sysinfo_request();
  virtual ~mcb_sysinfo_request();

  mcb_sysinfo_request(const mcb_sysinfo_request& from);

  inline mcb_sysinfo_request& operator=(const mcb_sysinfo_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_sysinfo_request& default_instance();

  void Swap(mcb_sysinfo_request* other);

  // implements Message ----------------------------------------------

  mcb_sysinfo_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_sysinfo_request& from);
  void MergeFrom(const mcb_sysinfo_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);

  // repeated int32 cids = 2;
  inline int cids_size() const;
  inline void clear_cids();
  static const int kCidsFieldNumber = 2;
  inline ::google::protobuf::int32 cids(int index) const;
  inline void set_cids(int index, ::google::protobuf::int32 value);
  inline void add_cids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      cids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_cids();

  // repeated int32 mids = 3;
  inline int mids_size() const;
  inline void clear_mids();
  static const int kMidsFieldNumber = 3;
  inline ::google::protobuf::int32 mids(int index) const;
  inline void set_mids(int index, ::google::protobuf::int32 value);
  inline void add_mids(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      mids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_mids();

  // @@protoc_insertion_point(class_scope:mcb_sysinfo_request)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > cids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > mids_;
  ::google::protobuf::int32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_sysinfo_request* default_instance_;
};
// -------------------------------------------------------------------

class mcb_sysinfo_common : public ::google::protobuf::Message {
 public:
  mcb_sysinfo_common();
  virtual ~mcb_sysinfo_common();

  mcb_sysinfo_common(const mcb_sysinfo_common& from);

  inline mcb_sysinfo_common& operator=(const mcb_sysinfo_common& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_sysinfo_common& default_instance();

  void Swap(mcb_sysinfo_common* other);

  // implements Message ----------------------------------------------

  mcb_sysinfo_common* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_sysinfo_common& from);
  void MergeFrom(const mcb_sysinfo_common& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 start_time = 1;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // optional int32 avail_mcbs = 2;
  inline bool has_avail_mcbs() const;
  inline void clear_avail_mcbs();
  static const int kAvailMcbsFieldNumber = 2;
  inline ::google::protobuf::int32 avail_mcbs() const;
  inline void set_avail_mcbs(::google::protobuf::int32 value);

  // optional int32 allocated_mcbs = 3;
  inline bool has_allocated_mcbs() const;
  inline void clear_allocated_mcbs();
  static const int kAllocatedMcbsFieldNumber = 3;
  inline ::google::protobuf::int32 allocated_mcbs() const;
  inline void set_allocated_mcbs(::google::protobuf::int32 value);

  // optional int32 prealloc_mcbs = 4;
  inline bool has_prealloc_mcbs() const;
  inline void clear_prealloc_mcbs();
  static const int kPreallocMcbsFieldNumber = 4;
  inline ::google::protobuf::int32 prealloc_mcbs() const;
  inline void set_prealloc_mcbs(::google::protobuf::int32 value);

  // optional int32 max_alloc_mcbs = 8;
  inline bool has_max_alloc_mcbs() const;
  inline void clear_max_alloc_mcbs();
  static const int kMaxAllocMcbsFieldNumber = 8;
  inline ::google::protobuf::int32 max_alloc_mcbs() const;
  inline void set_max_alloc_mcbs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcb_sysinfo_common)
 private:
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_avail_mcbs();
  inline void clear_has_avail_mcbs();
  inline void set_has_allocated_mcbs();
  inline void clear_has_allocated_mcbs();
  inline void set_has_prealloc_mcbs();
  inline void clear_has_prealloc_mcbs();
  inline void set_has_max_alloc_mcbs();
  inline void clear_has_max_alloc_mcbs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 start_time_;
  ::google::protobuf::int32 avail_mcbs_;
  ::google::protobuf::int32 allocated_mcbs_;
  ::google::protobuf::int32 prealloc_mcbs_;
  ::google::protobuf::int32 max_alloc_mcbs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_sysinfo_common* default_instance_;
};
// -------------------------------------------------------------------

class mcb_sysinfo_client : public ::google::protobuf::Message {
 public:
  mcb_sysinfo_client();
  virtual ~mcb_sysinfo_client();

  mcb_sysinfo_client(const mcb_sysinfo_client& from);

  inline mcb_sysinfo_client& operator=(const mcb_sysinfo_client& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_sysinfo_client& default_instance();

  void Swap(mcb_sysinfo_client* other);

  // implements Message ----------------------------------------------

  mcb_sysinfo_client* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_sysinfo_client& from);
  void MergeFrom(const mcb_sysinfo_client& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 cid = 1;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 1;
  inline ::google::protobuf::int32 cid() const;
  inline void set_cid(::google::protobuf::int32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bytes uuid = 3;
  inline bool has_uuid() const;
  inline void clear_uuid();
  static const int kUuidFieldNumber = 3;
  inline const ::std::string& uuid() const;
  inline void set_uuid(const ::std::string& value);
  inline void set_uuid(const char* value);
  inline void set_uuid(const void* value, size_t size);
  inline ::std::string* mutable_uuid();
  inline ::std::string* release_uuid();
  inline void set_allocated_uuid(::std::string* uuid);

  // optional string address = 4;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 4;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional string default_profile = 5;
  inline bool has_default_profile() const;
  inline void clear_default_profile();
  static const int kDefaultProfileFieldNumber = 5;
  inline const ::std::string& default_profile() const;
  inline void set_default_profile(const ::std::string& value);
  inline void set_default_profile(const char* value);
  inline void set_default_profile(const char* value, size_t size);
  inline ::std::string* mutable_default_profile();
  inline ::std::string* release_default_profile();
  inline void set_allocated_default_profile(::std::string* default_profile);

  // repeated string profiles = 6;
  inline int profiles_size() const;
  inline void clear_profiles();
  static const int kProfilesFieldNumber = 6;
  inline const ::std::string& profiles(int index) const;
  inline ::std::string* mutable_profiles(int index);
  inline void set_profiles(int index, const ::std::string& value);
  inline void set_profiles(int index, const char* value);
  inline void set_profiles(int index, const char* value, size_t size);
  inline ::std::string* add_profiles();
  inline void add_profiles(const ::std::string& value);
  inline void add_profiles(const char* value);
  inline void add_profiles(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& profiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_profiles();

  // repeated string groups = 7;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 7;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();

  // optional int32 start_time = 8;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 8;
  inline ::google::protobuf::int32 start_time() const;
  inline void set_start_time(::google::protobuf::int32 value);

  // optional int32 clock_sync_period = 9;
  inline bool has_clock_sync_period() const;
  inline void clear_clock_sync_period();
  static const int kClockSyncPeriodFieldNumber = 9;
  inline ::google::protobuf::int32 clock_sync_period() const;
  inline void set_clock_sync_period(::google::protobuf::int32 value);

  // optional int32 connection_latency = 10;
  inline bool has_connection_latency() const;
  inline void clear_connection_latency();
  static const int kConnectionLatencyFieldNumber = 10;
  inline ::google::protobuf::int32 connection_latency() const;
  inline void set_connection_latency(::google::protobuf::int32 value);

  // optional int32 output_queue_limit = 11;
  inline bool has_output_queue_limit() const;
  inline void clear_output_queue_limit();
  static const int kOutputQueueLimitFieldNumber = 11;
  inline ::google::protobuf::int32 output_queue_limit() const;
  inline void set_output_queue_limit(::google::protobuf::int32 value);

  // optional int32 output_queue_size = 12;
  inline bool has_output_queue_size() const;
  inline void clear_output_queue_size();
  static const int kOutputQueueSizeFieldNumber = 12;
  inline ::google::protobuf::int32 output_queue_size() const;
  inline void set_output_queue_size(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcb_sysinfo_client)
 private:
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_uuid();
  inline void clear_has_uuid();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_default_profile();
  inline void clear_has_default_profile();
  inline void set_has_start_time();
  inline void clear_has_start_time();
  inline void set_has_clock_sync_period();
  inline void clear_has_clock_sync_period();
  inline void set_has_connection_latency();
  inline void clear_has_connection_latency();
  inline void set_has_output_queue_limit();
  inline void clear_has_output_queue_limit();
  inline void set_has_output_queue_size();
  inline void clear_has_output_queue_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* uuid_;
  ::std::string* address_;
  ::google::protobuf::int32 cid_;
  ::google::protobuf::int32 start_time_;
  ::std::string* default_profile_;
  ::google::protobuf::RepeatedPtrField< ::std::string> profiles_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;
  ::google::protobuf::int32 clock_sync_period_;
  ::google::protobuf::int32 connection_latency_;
  ::google::protobuf::int32 output_queue_limit_;
  ::google::protobuf::int32 output_queue_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_sysinfo_client* default_instance_;
};
// -------------------------------------------------------------------

class mcb_sysinfo_message : public ::google::protobuf::Message {
 public:
  mcb_sysinfo_message();
  virtual ~mcb_sysinfo_message();

  mcb_sysinfo_message(const mcb_sysinfo_message& from);

  inline mcb_sysinfo_message& operator=(const mcb_sysinfo_message& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_sysinfo_message& default_instance();

  void Swap(mcb_sysinfo_message* other);

  // implements Message ----------------------------------------------

  mcb_sysinfo_message* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_sysinfo_message& from);
  void MergeFrom(const mcb_sysinfo_message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 mid = 1;
  inline bool has_mid() const;
  inline void clear_mid();
  static const int kMidFieldNumber = 1;
  inline ::google::protobuf::int32 mid() const;
  inline void set_mid(::google::protobuf::int32 value);

  // optional int32 cid = 2;
  inline bool has_cid() const;
  inline void clear_cid();
  static const int kCidFieldNumber = 2;
  inline ::google::protobuf::int32 cid() const;
  inline void set_cid(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string path = 4;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 4;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional int32 oflags = 5;
  inline bool has_oflags() const;
  inline void clear_oflags();
  static const int kOflagsFieldNumber = 5;
  inline ::google::protobuf::int32 oflags() const;
  inline void set_oflags(::google::protobuf::int32 value);

  // optional int32 sflags = 6;
  inline bool has_sflags() const;
  inline void clear_sflags();
  static const int kSflagsFieldNumber = 6;
  inline ::google::protobuf::int32 sflags() const;
  inline void set_sflags(::google::protobuf::int32 value);

  // optional int32 open_nr = 7;
  inline bool has_open_nr() const;
  inline void clear_open_nr();
  static const int kOpenNrFieldNumber = 7;
  inline ::google::protobuf::int32 open_nr() const;
  inline void set_open_nr(::google::protobuf::int32 value);

  // optional int32 subs_nr = 8;
  inline bool has_subs_nr() const;
  inline void clear_subs_nr();
  static const int kSubsNrFieldNumber = 8;
  inline ::google::protobuf::int32 subs_nr() const;
  inline void set_subs_nr(::google::protobuf::int32 value);

  // optional int32 snd_nr = 9;
  inline bool has_snd_nr() const;
  inline void clear_snd_nr();
  static const int kSndNrFieldNumber = 9;
  inline ::google::protobuf::int32 snd_nr() const;
  inline void set_snd_nr(::google::protobuf::int32 value);

  // optional int32 rcv_nr = 10;
  inline bool has_rcv_nr() const;
  inline void clear_rcv_nr();
  static const int kRcvNrFieldNumber = 10;
  inline ::google::protobuf::int32 rcv_nr() const;
  inline void set_rcv_nr(::google::protobuf::int32 value);

  // optional int32 avg_snd = 11;
  inline bool has_avg_snd() const;
  inline void clear_avg_snd();
  static const int kAvgSndFieldNumber = 11;
  inline ::google::protobuf::int32 avg_snd() const;
  inline void set_avg_snd(::google::protobuf::int32 value);

  // optional int32 avg_rcv = 12;
  inline bool has_avg_rcv() const;
  inline void clear_avg_rcv();
  static const int kAvgRcvFieldNumber = 12;
  inline ::google::protobuf::int32 avg_rcv() const;
  inline void set_avg_rcv(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:mcb_sysinfo_message)
 private:
  inline void set_has_mid();
  inline void clear_has_mid();
  inline void set_has_cid();
  inline void clear_has_cid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_oflags();
  inline void clear_has_oflags();
  inline void set_has_sflags();
  inline void clear_has_sflags();
  inline void set_has_open_nr();
  inline void clear_has_open_nr();
  inline void set_has_subs_nr();
  inline void clear_has_subs_nr();
  inline void set_has_snd_nr();
  inline void clear_has_snd_nr();
  inline void set_has_rcv_nr();
  inline void clear_has_rcv_nr();
  inline void set_has_avg_snd();
  inline void clear_has_avg_snd();
  inline void set_has_avg_rcv();
  inline void clear_has_avg_rcv();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mid_;
  ::google::protobuf::int32 cid_;
  ::std::string* name_;
  ::std::string* path_;
  ::google::protobuf::int32 oflags_;
  ::google::protobuf::int32 sflags_;
  ::google::protobuf::int32 open_nr_;
  ::google::protobuf::int32 subs_nr_;
  ::google::protobuf::int32 snd_nr_;
  ::google::protobuf::int32 rcv_nr_;
  ::google::protobuf::int32 avg_snd_;
  ::google::protobuf::int32 avg_rcv_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_sysinfo_message* default_instance_;
};
// -------------------------------------------------------------------

class mcb_sysinfo_reply : public ::google::protobuf::Message {
 public:
  mcb_sysinfo_reply();
  virtual ~mcb_sysinfo_reply();

  mcb_sysinfo_reply(const mcb_sysinfo_reply& from);

  inline mcb_sysinfo_reply& operator=(const mcb_sysinfo_reply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mcb_sysinfo_reply& default_instance();

  void Swap(mcb_sysinfo_reply* other);

  // implements Message ----------------------------------------------

  mcb_sysinfo_reply* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mcb_sysinfo_reply& from);
  void MergeFrom(const mcb_sysinfo_reply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::int32 flags() const;
  inline void set_flags(::google::protobuf::int32 value);

  // optional .mcb_sysinfo_common common = 2;
  inline bool has_common() const;
  inline void clear_common();
  static const int kCommonFieldNumber = 2;
  inline const ::mcb_sysinfo_common& common() const;
  inline ::mcb_sysinfo_common* mutable_common();
  inline ::mcb_sysinfo_common* release_common();
  inline void set_allocated_common(::mcb_sysinfo_common* common);

  // repeated .mcb_sysinfo_client clients = 3;
  inline int clients_size() const;
  inline void clear_clients();
  static const int kClientsFieldNumber = 3;
  inline const ::mcb_sysinfo_client& clients(int index) const;
  inline ::mcb_sysinfo_client* mutable_clients(int index);
  inline ::mcb_sysinfo_client* add_clients();
  inline const ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_client >&
      clients() const;
  inline ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_client >*
      mutable_clients();

  // repeated .mcb_sysinfo_message messages = 4;
  inline int messages_size() const;
  inline void clear_messages();
  static const int kMessagesFieldNumber = 4;
  inline const ::mcb_sysinfo_message& messages(int index) const;
  inline ::mcb_sysinfo_message* mutable_messages(int index);
  inline ::mcb_sysinfo_message* add_messages();
  inline const ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_message >&
      messages() const;
  inline ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_message >*
      mutable_messages();

  // @@protoc_insertion_point(class_scope:mcb_sysinfo_reply)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_common();
  inline void clear_has_common();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::mcb_sysinfo_common* common_;
  ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_client > clients_;
  ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_message > messages_;
  ::google::protobuf::int32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_mcb_2eproto();
  friend void protobuf_AssignDesc_mcb_2eproto();
  friend void protobuf_ShutdownFile_mcb_2eproto();

  void InitAsDefaultInstance();
  static mcb_sysinfo_reply* default_instance_;
};
// ===================================================================


// ===================================================================

// mcb_reg

// required uint32 ver_maj = 1;
inline bool mcb_reg::has_ver_maj() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_reg::set_has_ver_maj() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_reg::clear_has_ver_maj() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_reg::clear_ver_maj() {
  ver_maj_ = 0u;
  clear_has_ver_maj();
}
inline ::google::protobuf::uint32 mcb_reg::ver_maj() const {
  return ver_maj_;
}
inline void mcb_reg::set_ver_maj(::google::protobuf::uint32 value) {
  set_has_ver_maj();
  ver_maj_ = value;
}

// required uint32 ver_min = 2;
inline bool mcb_reg::has_ver_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_reg::set_has_ver_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_reg::clear_has_ver_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_reg::clear_ver_min() {
  ver_min_ = 0u;
  clear_has_ver_min();
}
inline ::google::protobuf::uint32 mcb_reg::ver_min() const {
  return ver_min_;
}
inline void mcb_reg::set_ver_min(::google::protobuf::uint32 value) {
  set_has_ver_min();
  ver_min_ = value;
}

// required string name = 3;
inline bool mcb_reg::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_reg::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_reg::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_reg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mcb_reg::name() const {
  return *name_;
}
inline void mcb_reg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_reg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_reg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_reg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mcb_reg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_reg::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string profile = 4;
inline int mcb_reg::profile_size() const {
  return profile_.size();
}
inline void mcb_reg::clear_profile() {
  profile_.Clear();
}
inline const ::std::string& mcb_reg::profile(int index) const {
  return profile_.Get(index);
}
inline ::std::string* mcb_reg::mutable_profile(int index) {
  return profile_.Mutable(index);
}
inline void mcb_reg::set_profile(int index, const ::std::string& value) {
  profile_.Mutable(index)->assign(value);
}
inline void mcb_reg::set_profile(int index, const char* value) {
  profile_.Mutable(index)->assign(value);
}
inline void mcb_reg::set_profile(int index, const char* value, size_t size) {
  profile_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_reg::add_profile() {
  return profile_.Add();
}
inline void mcb_reg::add_profile(const ::std::string& value) {
  profile_.Add()->assign(value);
}
inline void mcb_reg::add_profile(const char* value) {
  profile_.Add()->assign(value);
}
inline void mcb_reg::add_profile(const char* value, size_t size) {
  profile_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mcb_reg::profile() const {
  return profile_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mcb_reg::mutable_profile() {
  return &profile_;
}

// optional bytes uuid = 5;
inline bool mcb_reg::has_uuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_reg::set_has_uuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_reg::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_reg::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& mcb_reg::uuid() const {
  return *uuid_;
}
inline void mcb_reg::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mcb_reg::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mcb_reg::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_reg::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* mcb_reg::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_reg::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pswd = 6;
inline bool mcb_reg::has_pswd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mcb_reg::set_has_pswd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mcb_reg::clear_has_pswd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mcb_reg::clear_pswd() {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    pswd_->clear();
  }
  clear_has_pswd();
}
inline const ::std::string& mcb_reg::pswd() const {
  return *pswd_;
}
inline void mcb_reg::set_pswd(const ::std::string& value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void mcb_reg::set_pswd(const char* value) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(value);
}
inline void mcb_reg::set_pswd(const char* value, size_t size) {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  pswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_reg::mutable_pswd() {
  set_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    pswd_ = new ::std::string;
  }
  return pswd_;
}
inline ::std::string* mcb_reg::release_pswd() {
  clear_has_pswd();
  if (pswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pswd_;
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_reg::set_allocated_pswd(::std::string* pswd) {
  if (pswd_ != &::google::protobuf::internal::kEmptyString) {
    delete pswd_;
  }
  if (pswd) {
    set_has_pswd();
    pswd_ = pswd;
  } else {
    clear_has_pswd();
    pswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_subscribe

// required uint32 mid = 1;
inline bool mcb_subscribe::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_subscribe::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_subscribe::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_subscribe::clear_mid() {
  mid_ = 0u;
  clear_has_mid();
}
inline ::google::protobuf::uint32 mcb_subscribe::mid() const {
  return mid_;
}
inline void mcb_subscribe::set_mid(::google::protobuf::uint32 value) {
  set_has_mid();
  mid_ = value;
}

// required uint32 flags = 2;
inline bool mcb_subscribe::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_subscribe::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_subscribe::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_subscribe::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 mcb_subscribe::flags() const {
  return flags_;
}
inline void mcb_subscribe::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// mcb_mreg

// required string user = 1;
inline bool mcb_mreg::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mreg::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mreg::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mreg::clear_user() {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& mcb_mreg::user() const {
  return *user_;
}
inline void mcb_mreg::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void mcb_mreg::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(value);
}
inline void mcb_mreg::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mreg::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    user_ = new ::std::string;
  }
  return user_;
}
inline ::std::string* mcb_mreg::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mreg::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::kEmptyString) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 uid = 2;
inline bool mcb_mreg::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mreg::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mreg::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mreg::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 mcb_mreg::uid() const {
  return uid_;
}
inline void mcb_mreg::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 gid = 3;
inline bool mcb_mreg::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mreg::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mreg::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mreg::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 mcb_mreg::gid() const {
  return gid_;
}
inline void mcb_mreg::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// mcb_mopen_req

// required string name = 1;
inline bool mcb_mopen_req::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mopen_req::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mopen_req::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mopen_req::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mcb_mopen_req::name() const {
  return *name_;
}
inline void mcb_mopen_req::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_mopen_req::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_mopen_req::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mopen_req::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mcb_mopen_req::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mopen_req::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 flags = 2;
inline bool mcb_mopen_req::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mopen_req::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mopen_req::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mopen_req::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 mcb_mopen_req::flags() const {
  return flags_;
}
inline void mcb_mopen_req::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional uint32 type = 3;
inline bool mcb_mopen_req::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mopen_req::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mopen_req::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mopen_req::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 mcb_mopen_req::type() const {
  return type_;
}
inline void mcb_mopen_req::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 size = 4;
inline bool mcb_mopen_req::has_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_mopen_req::set_has_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_mopen_req::clear_has_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_mopen_req::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 mcb_mopen_req::size() const {
  return size_;
}
inline void mcb_mopen_req::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional bytes data = 5;
inline bool mcb_mopen_req::has_data() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_mopen_req::set_has_data() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_mopen_req::clear_has_data() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_mopen_req::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& mcb_mopen_req::data() const {
  return *data_;
}
inline void mcb_mopen_req::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void mcb_mopen_req::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void mcb_mopen_req::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mopen_req::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* mcb_mopen_req::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mopen_req::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mopen_rep

// required uint32 mid = 1;
inline bool mcb_mopen_rep::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mopen_rep::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mopen_rep::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mopen_rep::clear_mid() {
  mid_ = 0u;
  clear_has_mid();
}
inline ::google::protobuf::uint32 mcb_mopen_rep::mid() const {
  return mid_;
}
inline void mcb_mopen_rep::set_mid(::google::protobuf::uint32 value) {
  set_has_mid();
  mid_ = value;
}

// optional uint32 type = 2;
inline bool mcb_mopen_rep::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mopen_rep::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mopen_rep::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mopen_rep::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 mcb_mopen_rep::type() const {
  return type_;
}
inline void mcb_mopen_rep::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 size = 3;
inline bool mcb_mopen_rep::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mopen_rep::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mopen_rep::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mopen_rep::clear_size() {
  size_ = 0u;
  clear_has_size();
}
inline ::google::protobuf::uint32 mcb_mopen_rep::size() const {
  return size_;
}
inline void mcb_mopen_rep::set_size(::google::protobuf::uint32 value) {
  set_has_size();
  size_ = value;
}

// optional bool already_opened = 4;
inline bool mcb_mopen_rep::has_already_opened() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_mopen_rep::set_has_already_opened() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_mopen_rep::clear_has_already_opened() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_mopen_rep::clear_already_opened() {
  already_opened_ = false;
  clear_has_already_opened();
}
inline bool mcb_mopen_rep::already_opened() const {
  return already_opened_;
}
inline void mcb_mopen_rep::set_already_opened(bool value) {
  set_has_already_opened();
  already_opened_ = value;
}

// -------------------------------------------------------------------

// mcb_mlink

// required string link = 1;
inline bool mcb_mlink::has_link() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mlink::set_has_link() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mlink::clear_has_link() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mlink::clear_link() {
  if (link_ != &::google::protobuf::internal::kEmptyString) {
    link_->clear();
  }
  clear_has_link();
}
inline const ::std::string& mcb_mlink::link() const {
  return *link_;
}
inline void mcb_mlink::set_link(const ::std::string& value) {
  set_has_link();
  if (link_ == &::google::protobuf::internal::kEmptyString) {
    link_ = new ::std::string;
  }
  link_->assign(value);
}
inline void mcb_mlink::set_link(const char* value) {
  set_has_link();
  if (link_ == &::google::protobuf::internal::kEmptyString) {
    link_ = new ::std::string;
  }
  link_->assign(value);
}
inline void mcb_mlink::set_link(const char* value, size_t size) {
  set_has_link();
  if (link_ == &::google::protobuf::internal::kEmptyString) {
    link_ = new ::std::string;
  }
  link_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mlink::mutable_link() {
  set_has_link();
  if (link_ == &::google::protobuf::internal::kEmptyString) {
    link_ = new ::std::string;
  }
  return link_;
}
inline ::std::string* mcb_mlink::release_link() {
  clear_has_link();
  if (link_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_;
    link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mlink::set_allocated_link(::std::string* link) {
  if (link_ != &::google::protobuf::internal::kEmptyString) {
    delete link_;
  }
  if (link) {
    set_has_link();
    link_ = link;
  } else {
    clear_has_link();
    link_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string orig = 2;
inline bool mcb_mlink::has_orig() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mlink::set_has_orig() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mlink::clear_has_orig() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mlink::clear_orig() {
  if (orig_ != &::google::protobuf::internal::kEmptyString) {
    orig_->clear();
  }
  clear_has_orig();
}
inline const ::std::string& mcb_mlink::orig() const {
  return *orig_;
}
inline void mcb_mlink::set_orig(const ::std::string& value) {
  set_has_orig();
  if (orig_ == &::google::protobuf::internal::kEmptyString) {
    orig_ = new ::std::string;
  }
  orig_->assign(value);
}
inline void mcb_mlink::set_orig(const char* value) {
  set_has_orig();
  if (orig_ == &::google::protobuf::internal::kEmptyString) {
    orig_ = new ::std::string;
  }
  orig_->assign(value);
}
inline void mcb_mlink::set_orig(const char* value, size_t size) {
  set_has_orig();
  if (orig_ == &::google::protobuf::internal::kEmptyString) {
    orig_ = new ::std::string;
  }
  orig_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mlink::mutable_orig() {
  set_has_orig();
  if (orig_ == &::google::protobuf::internal::kEmptyString) {
    orig_ = new ::std::string;
  }
  return orig_;
}
inline ::std::string* mcb_mlink::release_orig() {
  clear_has_orig();
  if (orig_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orig_;
    orig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mlink::set_allocated_orig(::std::string* orig) {
  if (orig_ != &::google::protobuf::internal::kEmptyString) {
    delete orig_;
  }
  if (orig) {
    set_has_orig();
    orig_ = orig;
  } else {
    clear_has_orig();
    orig_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool soft = 3;
inline bool mcb_mlink::has_soft() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mlink::set_has_soft() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mlink::clear_has_soft() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mlink::clear_soft() {
  soft_ = false;
  clear_has_soft();
}
inline bool mcb_mlink::soft() const {
  return soft_;
}
inline void mcb_mlink::set_soft(bool value) {
  set_has_soft();
  soft_ = value;
}

// -------------------------------------------------------------------

// mcb_munlink

// required string name = 1;
inline bool mcb_munlink::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_munlink::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_munlink::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_munlink::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mcb_munlink::name() const {
  return *name_;
}
inline void mcb_munlink::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_munlink::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_munlink::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_munlink::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mcb_munlink::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_munlink::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mmove

// required string from = 1;
inline bool mcb_mmove::has_from() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mmove::set_has_from() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mmove::clear_has_from() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mmove::clear_from() {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    from_->clear();
  }
  clear_has_from();
}
inline const ::std::string& mcb_mmove::from() const {
  return *from_;
}
inline void mcb_mmove::set_from(const ::std::string& value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void mcb_mmove::set_from(const char* value) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(value);
}
inline void mcb_mmove::set_from(const char* value, size_t size) {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  from_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mmove::mutable_from() {
  set_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    from_ = new ::std::string;
  }
  return from_;
}
inline ::std::string* mcb_mmove::release_from() {
  clear_has_from();
  if (from_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = from_;
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mmove::set_allocated_from(::std::string* from) {
  if (from_ != &::google::protobuf::internal::kEmptyString) {
    delete from_;
  }
  if (from) {
    set_has_from();
    from_ = from;
  } else {
    clear_has_from();
    from_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string to = 2;
inline bool mcb_mmove::has_to() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mmove::set_has_to() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mmove::clear_has_to() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mmove::clear_to() {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    to_->clear();
  }
  clear_has_to();
}
inline const ::std::string& mcb_mmove::to() const {
  return *to_;
}
inline void mcb_mmove::set_to(const ::std::string& value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void mcb_mmove::set_to(const char* value) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(value);
}
inline void mcb_mmove::set_to(const char* value, size_t size) {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  to_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mmove::mutable_to() {
  set_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    to_ = new ::std::string;
  }
  return to_;
}
inline ::std::string* mcb_mmove::release_to() {
  clear_has_to();
  if (to_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = to_;
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mmove::set_allocated_to(::std::string* to) {
  if (to_ != &::google::protobuf::internal::kEmptyString) {
    delete to_;
  }
  if (to) {
    set_has_to();
    to_ = to;
  } else {
    clear_has_to();
    to_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mlist_req

// optional string mask = 1;
inline bool mcb_mlist_req::has_mask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mlist_req::set_has_mask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mlist_req::clear_has_mask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mlist_req::clear_mask() {
  if (mask_ != &::google::protobuf::internal::kEmptyString) {
    mask_->clear();
  }
  clear_has_mask();
}
inline const ::std::string& mcb_mlist_req::mask() const {
  return *mask_;
}
inline void mcb_mlist_req::set_mask(const ::std::string& value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
}
inline void mcb_mlist_req::set_mask(const char* value) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(value);
}
inline void mcb_mlist_req::set_mask(const char* value, size_t size) {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  mask_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mlist_req::mutable_mask() {
  set_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    mask_ = new ::std::string;
  }
  return mask_;
}
inline ::std::string* mcb_mlist_req::release_mask() {
  clear_has_mask();
  if (mask_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mask_;
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mlist_req::set_allocated_mask(::std::string* mask) {
  if (mask_ != &::google::protobuf::internal::kEmptyString) {
    delete mask_;
  }
  if (mask) {
    set_has_mask();
    mask_ = mask;
  } else {
    clear_has_mask();
    mask_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 flags = 2;
inline bool mcb_mlist_req::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mlist_req::set_has_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mlist_req::clear_has_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mlist_req::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 mcb_mlist_req::flags() const {
  return flags_;
}
inline void mcb_mlist_req::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional string profile = 3;
inline bool mcb_mlist_req::has_profile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mlist_req::set_has_profile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mlist_req::clear_has_profile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mlist_req::clear_profile() {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    profile_->clear();
  }
  clear_has_profile();
}
inline const ::std::string& mcb_mlist_req::profile() const {
  return *profile_;
}
inline void mcb_mlist_req::set_profile(const ::std::string& value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void mcb_mlist_req::set_profile(const char* value) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(value);
}
inline void mcb_mlist_req::set_profile(const char* value, size_t size) {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  profile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mlist_req::mutable_profile() {
  set_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    profile_ = new ::std::string;
  }
  return profile_;
}
inline ::std::string* mcb_mlist_req::release_profile() {
  clear_has_profile();
  if (profile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = profile_;
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mlist_req::set_allocated_profile(::std::string* profile) {
  if (profile_ != &::google::protobuf::internal::kEmptyString) {
    delete profile_;
  }
  if (profile) {
    set_has_profile();
    profile_ = profile;
  } else {
    clear_has_profile();
    profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mlist_rep

// repeated string names = 1;
inline int mcb_mlist_rep::names_size() const {
  return names_.size();
}
inline void mcb_mlist_rep::clear_names() {
  names_.Clear();
}
inline const ::std::string& mcb_mlist_rep::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* mcb_mlist_rep::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void mcb_mlist_rep::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void mcb_mlist_rep::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void mcb_mlist_rep::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mlist_rep::add_names() {
  return names_.Add();
}
inline void mcb_mlist_rep::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void mcb_mlist_rep::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void mcb_mlist_rep::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mcb_mlist_rep::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mcb_mlist_rep::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// mcb_mstat

// required uint32 st_mid = 1;
inline bool mcb_mstat::has_st_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mstat::set_has_st_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mstat::clear_has_st_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mstat::clear_st_mid() {
  st_mid_ = 0u;
  clear_has_st_mid();
}
inline ::google::protobuf::uint32 mcb_mstat::st_mid() const {
  return st_mid_;
}
inline void mcb_mstat::set_st_mid(::google::protobuf::uint32 value) {
  set_has_st_mid();
  st_mid_ = value;
}

// required uint32 st_type = 2;
inline bool mcb_mstat::has_st_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mstat::set_has_st_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mstat::clear_has_st_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mstat::clear_st_type() {
  st_type_ = 0u;
  clear_has_st_type();
}
inline ::google::protobuf::uint32 mcb_mstat::st_type() const {
  return st_type_;
}
inline void mcb_mstat::set_st_type(::google::protobuf::uint32 value) {
  set_has_st_type();
  st_type_ = value;
}

// required uint32 st_nlink = 3;
inline bool mcb_mstat::has_st_nlink() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mstat::set_has_st_nlink() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mstat::clear_has_st_nlink() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mstat::clear_st_nlink() {
  st_nlink_ = 0u;
  clear_has_st_nlink();
}
inline ::google::protobuf::uint32 mcb_mstat::st_nlink() const {
  return st_nlink_;
}
inline void mcb_mstat::set_st_nlink(::google::protobuf::uint32 value) {
  set_has_st_nlink();
  st_nlink_ = value;
}

// required uint32 st_uid = 4;
inline bool mcb_mstat::has_st_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_mstat::set_has_st_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_mstat::clear_has_st_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_mstat::clear_st_uid() {
  st_uid_ = 0u;
  clear_has_st_uid();
}
inline ::google::protobuf::uint32 mcb_mstat::st_uid() const {
  return st_uid_;
}
inline void mcb_mstat::set_st_uid(::google::protobuf::uint32 value) {
  set_has_st_uid();
  st_uid_ = value;
}

// required uint32 st_gid = 5;
inline bool mcb_mstat::has_st_gid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_mstat::set_has_st_gid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_mstat::clear_has_st_gid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_mstat::clear_st_gid() {
  st_gid_ = 0u;
  clear_has_st_gid();
}
inline ::google::protobuf::uint32 mcb_mstat::st_gid() const {
  return st_gid_;
}
inline void mcb_mstat::set_st_gid(::google::protobuf::uint32 value) {
  set_has_st_gid();
  st_gid_ = value;
}

// required uint32 st_size = 6;
inline bool mcb_mstat::has_st_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mcb_mstat::set_has_st_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mcb_mstat::clear_has_st_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mcb_mstat::clear_st_size() {
  st_size_ = 0u;
  clear_has_st_size();
}
inline ::google::protobuf::uint32 mcb_mstat::st_size() const {
  return st_size_;
}
inline void mcb_mstat::set_st_size(::google::protobuf::uint32 value) {
  set_has_st_size();
  st_size_ = value;
}

// required uint32 st_atime = 7;
inline bool mcb_mstat::has_st_atime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mcb_mstat::set_has_st_atime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mcb_mstat::clear_has_st_atime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mcb_mstat::clear_st_atime() {
  st_atime_ = 0u;
  clear_has_st_atime();
}
inline ::google::protobuf::uint32 mcb_mstat::st_atime() const {
  return st_atime_;
}
inline void mcb_mstat::set_st_atime(::google::protobuf::uint32 value) {
  set_has_st_atime();
  st_atime_ = value;
}

// required uint32 st_mtime = 8;
inline bool mcb_mstat::has_st_mtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void mcb_mstat::set_has_st_mtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void mcb_mstat::clear_has_st_mtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void mcb_mstat::clear_st_mtime() {
  st_mtime_ = 0u;
  clear_has_st_mtime();
}
inline ::google::protobuf::uint32 mcb_mstat::st_mtime() const {
  return st_mtime_;
}
inline void mcb_mstat::set_st_mtime(::google::protobuf::uint32 value) {
  set_has_st_mtime();
  st_mtime_ = value;
}

// required uint64 st_ctime = 9;
inline bool mcb_mstat::has_st_ctime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void mcb_mstat::set_has_st_ctime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void mcb_mstat::clear_has_st_ctime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void mcb_mstat::clear_st_ctime() {
  st_ctime_ = GOOGLE_ULONGLONG(0);
  clear_has_st_ctime();
}
inline ::google::protobuf::uint64 mcb_mstat::st_ctime() const {
  return st_ctime_;
}
inline void mcb_mstat::set_st_ctime(::google::protobuf::uint64 value) {
  set_has_st_ctime();
  st_ctime_ = value;
}

// -------------------------------------------------------------------

// mcb_mattr_read

// required uint32 mid = 1;
inline bool mcb_mattr_read::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mattr_read::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mattr_read::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mattr_read::clear_mid() {
  mid_ = 0u;
  clear_has_mid();
}
inline ::google::protobuf::uint32 mcb_mattr_read::mid() const {
  return mid_;
}
inline void mcb_mattr_read::set_mid(::google::protobuf::uint32 value) {
  set_has_mid();
  mid_ = value;
}

// required string key = 2;
inline bool mcb_mattr_read::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mattr_read::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mattr_read::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mattr_read::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& mcb_mattr_read::key() const {
  return *key_;
}
inline void mcb_mattr_read::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mcb_mattr_read::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mcb_mattr_read::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mattr_read::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* mcb_mattr_read::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mattr_read::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 len = 3;
inline bool mcb_mattr_read::has_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mattr_read::set_has_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mattr_read::clear_has_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mattr_read::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 mcb_mattr_read::len() const {
  return len_;
}
inline void mcb_mattr_read::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// -------------------------------------------------------------------

// mcb_mattr_write

// required uint32 mid = 1;
inline bool mcb_mattr_write::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mattr_write::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mattr_write::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mattr_write::clear_mid() {
  mid_ = 0u;
  clear_has_mid();
}
inline ::google::protobuf::uint32 mcb_mattr_write::mid() const {
  return mid_;
}
inline void mcb_mattr_write::set_mid(::google::protobuf::uint32 value) {
  set_has_mid();
  mid_ = value;
}

// required string key = 2;
inline bool mcb_mattr_write::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mattr_write::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mattr_write::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mattr_write::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& mcb_mattr_write::key() const {
  return *key_;
}
inline void mcb_mattr_write::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mcb_mattr_write::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void mcb_mattr_write::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mattr_write::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* mcb_mattr_write::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mattr_write::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 3;
inline bool mcb_mattr_write::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_mattr_write::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_mattr_write::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_mattr_write::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& mcb_mattr_write::value() const {
  return *value_;
}
inline void mcb_mattr_write::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void mcb_mattr_write::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void mcb_mattr_write::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mattr_write::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* mcb_mattr_write::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mattr_write::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mattrs_read

// required uint32 mid = 1;
inline bool mcb_mattrs_read::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mattrs_read::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mattrs_read::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mattrs_read::clear_mid() {
  mid_ = 0u;
  clear_has_mid();
}
inline ::google::protobuf::uint32 mcb_mattrs_read::mid() const {
  return mid_;
}
inline void mcb_mattrs_read::set_mid(::google::protobuf::uint32 value) {
  set_has_mid();
  mid_ = value;
}

// required uint32 len = 2;
inline bool mcb_mattrs_read::has_len() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mattrs_read::set_has_len() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mattrs_read::clear_has_len() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mattrs_read::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 mcb_mattrs_read::len() const {
  return len_;
}
inline void mcb_mattrs_read::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// -------------------------------------------------------------------

// mcb_msave

// required uint32 len = 1;
inline bool mcb_msave::has_len() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_msave::set_has_len() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_msave::clear_has_len() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_msave::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 mcb_msave::len() const {
  return len_;
}
inline void mcb_msave::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// required string sep = 2;
inline bool mcb_msave::has_sep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_msave::set_has_sep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_msave::clear_has_sep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_msave::clear_sep() {
  if (sep_ != &::google::protobuf::internal::kEmptyString) {
    sep_->clear();
  }
  clear_has_sep();
}
inline const ::std::string& mcb_msave::sep() const {
  return *sep_;
}
inline void mcb_msave::set_sep(const ::std::string& value) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(value);
}
inline void mcb_msave::set_sep(const char* value) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(value);
}
inline void mcb_msave::set_sep(const char* value, size_t size) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_msave::mutable_sep() {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  return sep_;
}
inline ::std::string* mcb_msave::release_sep() {
  clear_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sep_;
    sep_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_msave::set_allocated_sep(::std::string* sep) {
  if (sep_ != &::google::protobuf::internal::kEmptyString) {
    delete sep_;
  }
  if (sep) {
    set_has_sep();
    sep_ = sep;
  } else {
    clear_has_sep();
    sep_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_mload

// required string text = 1;
inline bool mcb_mload::has_text() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_mload::set_has_text() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_mload::clear_has_text() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_mload::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& mcb_mload::text() const {
  return *text_;
}
inline void mcb_mload::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void mcb_mload::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void mcb_mload::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mload::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* mcb_mload::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mload::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sep = 2;
inline bool mcb_mload::has_sep() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_mload::set_has_sep() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_mload::clear_has_sep() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_mload::clear_sep() {
  if (sep_ != &::google::protobuf::internal::kEmptyString) {
    sep_->clear();
  }
  clear_has_sep();
}
inline const ::std::string& mcb_mload::sep() const {
  return *sep_;
}
inline void mcb_mload::set_sep(const ::std::string& value) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(value);
}
inline void mcb_mload::set_sep(const char* value) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(value);
}
inline void mcb_mload::set_sep(const char* value, size_t size) {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  sep_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_mload::mutable_sep() {
  set_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    sep_ = new ::std::string;
  }
  return sep_;
}
inline ::std::string* mcb_mload::release_sep() {
  clear_has_sep();
  if (sep_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sep_;
    sep_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_mload::set_allocated_sep(::std::string* sep) {
  if (sep_ != &::google::protobuf::internal::kEmptyString) {
    delete sep_;
  }
  if (sep) {
    set_has_sep();
    sep_ = sep;
  } else {
    clear_has_sep();
    sep_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// mcb_sysinfo_request

// required int32 flags = 1;
inline bool mcb_sysinfo_request::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_sysinfo_request::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_sysinfo_request::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_sysinfo_request::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 mcb_sysinfo_request::flags() const {
  return flags_;
}
inline void mcb_sysinfo_request::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// repeated int32 cids = 2;
inline int mcb_sysinfo_request::cids_size() const {
  return cids_.size();
}
inline void mcb_sysinfo_request::clear_cids() {
  cids_.Clear();
}
inline ::google::protobuf::int32 mcb_sysinfo_request::cids(int index) const {
  return cids_.Get(index);
}
inline void mcb_sysinfo_request::set_cids(int index, ::google::protobuf::int32 value) {
  cids_.Set(index, value);
}
inline void mcb_sysinfo_request::add_cids(::google::protobuf::int32 value) {
  cids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
mcb_sysinfo_request::cids() const {
  return cids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
mcb_sysinfo_request::mutable_cids() {
  return &cids_;
}

// repeated int32 mids = 3;
inline int mcb_sysinfo_request::mids_size() const {
  return mids_.size();
}
inline void mcb_sysinfo_request::clear_mids() {
  mids_.Clear();
}
inline ::google::protobuf::int32 mcb_sysinfo_request::mids(int index) const {
  return mids_.Get(index);
}
inline void mcb_sysinfo_request::set_mids(int index, ::google::protobuf::int32 value) {
  mids_.Set(index, value);
}
inline void mcb_sysinfo_request::add_mids(::google::protobuf::int32 value) {
  mids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
mcb_sysinfo_request::mids() const {
  return mids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
mcb_sysinfo_request::mutable_mids() {
  return &mids_;
}

// -------------------------------------------------------------------

// mcb_sysinfo_common

// optional int32 start_time = 1;
inline bool mcb_sysinfo_common::has_start_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_sysinfo_common::set_has_start_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_sysinfo_common::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_sysinfo_common::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 mcb_sysinfo_common::start_time() const {
  return start_time_;
}
inline void mcb_sysinfo_common::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int32 avail_mcbs = 2;
inline bool mcb_sysinfo_common::has_avail_mcbs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_sysinfo_common::set_has_avail_mcbs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_sysinfo_common::clear_has_avail_mcbs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_sysinfo_common::clear_avail_mcbs() {
  avail_mcbs_ = 0;
  clear_has_avail_mcbs();
}
inline ::google::protobuf::int32 mcb_sysinfo_common::avail_mcbs() const {
  return avail_mcbs_;
}
inline void mcb_sysinfo_common::set_avail_mcbs(::google::protobuf::int32 value) {
  set_has_avail_mcbs();
  avail_mcbs_ = value;
}

// optional int32 allocated_mcbs = 3;
inline bool mcb_sysinfo_common::has_allocated_mcbs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_sysinfo_common::set_has_allocated_mcbs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_sysinfo_common::clear_has_allocated_mcbs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_sysinfo_common::clear_allocated_mcbs() {
  allocated_mcbs_ = 0;
  clear_has_allocated_mcbs();
}
inline ::google::protobuf::int32 mcb_sysinfo_common::allocated_mcbs() const {
  return allocated_mcbs_;
}
inline void mcb_sysinfo_common::set_allocated_mcbs(::google::protobuf::int32 value) {
  set_has_allocated_mcbs();
  allocated_mcbs_ = value;
}

// optional int32 prealloc_mcbs = 4;
inline bool mcb_sysinfo_common::has_prealloc_mcbs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_sysinfo_common::set_has_prealloc_mcbs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_sysinfo_common::clear_has_prealloc_mcbs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_sysinfo_common::clear_prealloc_mcbs() {
  prealloc_mcbs_ = 0;
  clear_has_prealloc_mcbs();
}
inline ::google::protobuf::int32 mcb_sysinfo_common::prealloc_mcbs() const {
  return prealloc_mcbs_;
}
inline void mcb_sysinfo_common::set_prealloc_mcbs(::google::protobuf::int32 value) {
  set_has_prealloc_mcbs();
  prealloc_mcbs_ = value;
}

// optional int32 max_alloc_mcbs = 8;
inline bool mcb_sysinfo_common::has_max_alloc_mcbs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_sysinfo_common::set_has_max_alloc_mcbs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_sysinfo_common::clear_has_max_alloc_mcbs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_sysinfo_common::clear_max_alloc_mcbs() {
  max_alloc_mcbs_ = 0;
  clear_has_max_alloc_mcbs();
}
inline ::google::protobuf::int32 mcb_sysinfo_common::max_alloc_mcbs() const {
  return max_alloc_mcbs_;
}
inline void mcb_sysinfo_common::set_max_alloc_mcbs(::google::protobuf::int32 value) {
  set_has_max_alloc_mcbs();
  max_alloc_mcbs_ = value;
}

// -------------------------------------------------------------------

// mcb_sysinfo_client

// required int32 cid = 1;
inline bool mcb_sysinfo_client::has_cid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_sysinfo_client::set_has_cid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_sysinfo_client::clear_has_cid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_sysinfo_client::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::cid() const {
  return cid_;
}
inline void mcb_sysinfo_client::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
}

// optional string name = 2;
inline bool mcb_sysinfo_client::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_sysinfo_client::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_sysinfo_client::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_sysinfo_client::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mcb_sysinfo_client::name() const {
  return *name_;
}
inline void mcb_sysinfo_client::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_sysinfo_client::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_sysinfo_client::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mcb_sysinfo_client::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_client::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes uuid = 3;
inline bool mcb_sysinfo_client::has_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_sysinfo_client::set_has_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_sysinfo_client::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_sysinfo_client::clear_uuid() {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    uuid_->clear();
  }
  clear_has_uuid();
}
inline const ::std::string& mcb_sysinfo_client::uuid() const {
  return *uuid_;
}
inline void mcb_sysinfo_client::set_uuid(const ::std::string& value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mcb_sysinfo_client::set_uuid(const char* value) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(value);
}
inline void mcb_sysinfo_client::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::mutable_uuid() {
  set_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    uuid_ = new ::std::string;
  }
  return uuid_;
}
inline ::std::string* mcb_sysinfo_client::release_uuid() {
  clear_has_uuid();
  if (uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = uuid_;
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_client::set_allocated_uuid(::std::string* uuid) {
  if (uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete uuid_;
  }
  if (uuid) {
    set_has_uuid();
    uuid_ = uuid;
  } else {
    clear_has_uuid();
    uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 4;
inline bool mcb_sysinfo_client::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_sysinfo_client::set_has_address() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_sysinfo_client::clear_has_address() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_sysinfo_client::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& mcb_sysinfo_client::address() const {
  return *address_;
}
inline void mcb_sysinfo_client::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void mcb_sysinfo_client::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void mcb_sysinfo_client::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* mcb_sysinfo_client::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_client::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string default_profile = 5;
inline bool mcb_sysinfo_client::has_default_profile() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_sysinfo_client::set_has_default_profile() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_sysinfo_client::clear_has_default_profile() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_sysinfo_client::clear_default_profile() {
  if (default_profile_ != &::google::protobuf::internal::kEmptyString) {
    default_profile_->clear();
  }
  clear_has_default_profile();
}
inline const ::std::string& mcb_sysinfo_client::default_profile() const {
  return *default_profile_;
}
inline void mcb_sysinfo_client::set_default_profile(const ::std::string& value) {
  set_has_default_profile();
  if (default_profile_ == &::google::protobuf::internal::kEmptyString) {
    default_profile_ = new ::std::string;
  }
  default_profile_->assign(value);
}
inline void mcb_sysinfo_client::set_default_profile(const char* value) {
  set_has_default_profile();
  if (default_profile_ == &::google::protobuf::internal::kEmptyString) {
    default_profile_ = new ::std::string;
  }
  default_profile_->assign(value);
}
inline void mcb_sysinfo_client::set_default_profile(const char* value, size_t size) {
  set_has_default_profile();
  if (default_profile_ == &::google::protobuf::internal::kEmptyString) {
    default_profile_ = new ::std::string;
  }
  default_profile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::mutable_default_profile() {
  set_has_default_profile();
  if (default_profile_ == &::google::protobuf::internal::kEmptyString) {
    default_profile_ = new ::std::string;
  }
  return default_profile_;
}
inline ::std::string* mcb_sysinfo_client::release_default_profile() {
  clear_has_default_profile();
  if (default_profile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = default_profile_;
    default_profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_client::set_allocated_default_profile(::std::string* default_profile) {
  if (default_profile_ != &::google::protobuf::internal::kEmptyString) {
    delete default_profile_;
  }
  if (default_profile) {
    set_has_default_profile();
    default_profile_ = default_profile;
  } else {
    clear_has_default_profile();
    default_profile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string profiles = 6;
inline int mcb_sysinfo_client::profiles_size() const {
  return profiles_.size();
}
inline void mcb_sysinfo_client::clear_profiles() {
  profiles_.Clear();
}
inline const ::std::string& mcb_sysinfo_client::profiles(int index) const {
  return profiles_.Get(index);
}
inline ::std::string* mcb_sysinfo_client::mutable_profiles(int index) {
  return profiles_.Mutable(index);
}
inline void mcb_sysinfo_client::set_profiles(int index, const ::std::string& value) {
  profiles_.Mutable(index)->assign(value);
}
inline void mcb_sysinfo_client::set_profiles(int index, const char* value) {
  profiles_.Mutable(index)->assign(value);
}
inline void mcb_sysinfo_client::set_profiles(int index, const char* value, size_t size) {
  profiles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::add_profiles() {
  return profiles_.Add();
}
inline void mcb_sysinfo_client::add_profiles(const ::std::string& value) {
  profiles_.Add()->assign(value);
}
inline void mcb_sysinfo_client::add_profiles(const char* value) {
  profiles_.Add()->assign(value);
}
inline void mcb_sysinfo_client::add_profiles(const char* value, size_t size) {
  profiles_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mcb_sysinfo_client::profiles() const {
  return profiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mcb_sysinfo_client::mutable_profiles() {
  return &profiles_;
}

// repeated string groups = 7;
inline int mcb_sysinfo_client::groups_size() const {
  return groups_.size();
}
inline void mcb_sysinfo_client::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& mcb_sysinfo_client::groups(int index) const {
  return groups_.Get(index);
}
inline ::std::string* mcb_sysinfo_client::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline void mcb_sysinfo_client::set_groups(int index, const ::std::string& value) {
  groups_.Mutable(index)->assign(value);
}
inline void mcb_sysinfo_client::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
}
inline void mcb_sysinfo_client::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_client::add_groups() {
  return groups_.Add();
}
inline void mcb_sysinfo_client::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
}
inline void mcb_sysinfo_client::add_groups(const char* value) {
  groups_.Add()->assign(value);
}
inline void mcb_sysinfo_client::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
mcb_sysinfo_client::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
mcb_sysinfo_client::mutable_groups() {
  return &groups_;
}

// optional int32 start_time = 8;
inline bool mcb_sysinfo_client::has_start_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void mcb_sysinfo_client::set_has_start_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void mcb_sysinfo_client::clear_has_start_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void mcb_sysinfo_client::clear_start_time() {
  start_time_ = 0;
  clear_has_start_time();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::start_time() const {
  return start_time_;
}
inline void mcb_sysinfo_client::set_start_time(::google::protobuf::int32 value) {
  set_has_start_time();
  start_time_ = value;
}

// optional int32 clock_sync_period = 9;
inline bool mcb_sysinfo_client::has_clock_sync_period() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void mcb_sysinfo_client::set_has_clock_sync_period() {
  _has_bits_[0] |= 0x00000100u;
}
inline void mcb_sysinfo_client::clear_has_clock_sync_period() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void mcb_sysinfo_client::clear_clock_sync_period() {
  clock_sync_period_ = 0;
  clear_has_clock_sync_period();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::clock_sync_period() const {
  return clock_sync_period_;
}
inline void mcb_sysinfo_client::set_clock_sync_period(::google::protobuf::int32 value) {
  set_has_clock_sync_period();
  clock_sync_period_ = value;
}

// optional int32 connection_latency = 10;
inline bool mcb_sysinfo_client::has_connection_latency() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void mcb_sysinfo_client::set_has_connection_latency() {
  _has_bits_[0] |= 0x00000200u;
}
inline void mcb_sysinfo_client::clear_has_connection_latency() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void mcb_sysinfo_client::clear_connection_latency() {
  connection_latency_ = 0;
  clear_has_connection_latency();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::connection_latency() const {
  return connection_latency_;
}
inline void mcb_sysinfo_client::set_connection_latency(::google::protobuf::int32 value) {
  set_has_connection_latency();
  connection_latency_ = value;
}

// optional int32 output_queue_limit = 11;
inline bool mcb_sysinfo_client::has_output_queue_limit() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void mcb_sysinfo_client::set_has_output_queue_limit() {
  _has_bits_[0] |= 0x00000400u;
}
inline void mcb_sysinfo_client::clear_has_output_queue_limit() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void mcb_sysinfo_client::clear_output_queue_limit() {
  output_queue_limit_ = 0;
  clear_has_output_queue_limit();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::output_queue_limit() const {
  return output_queue_limit_;
}
inline void mcb_sysinfo_client::set_output_queue_limit(::google::protobuf::int32 value) {
  set_has_output_queue_limit();
  output_queue_limit_ = value;
}

// optional int32 output_queue_size = 12;
inline bool mcb_sysinfo_client::has_output_queue_size() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void mcb_sysinfo_client::set_has_output_queue_size() {
  _has_bits_[0] |= 0x00000800u;
}
inline void mcb_sysinfo_client::clear_has_output_queue_size() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void mcb_sysinfo_client::clear_output_queue_size() {
  output_queue_size_ = 0;
  clear_has_output_queue_size();
}
inline ::google::protobuf::int32 mcb_sysinfo_client::output_queue_size() const {
  return output_queue_size_;
}
inline void mcb_sysinfo_client::set_output_queue_size(::google::protobuf::int32 value) {
  set_has_output_queue_size();
  output_queue_size_ = value;
}

// -------------------------------------------------------------------

// mcb_sysinfo_message

// required int32 mid = 1;
inline bool mcb_sysinfo_message::has_mid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_sysinfo_message::set_has_mid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_sysinfo_message::clear_has_mid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_sysinfo_message::clear_mid() {
  mid_ = 0;
  clear_has_mid();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::mid() const {
  return mid_;
}
inline void mcb_sysinfo_message::set_mid(::google::protobuf::int32 value) {
  set_has_mid();
  mid_ = value;
}

// optional int32 cid = 2;
inline bool mcb_sysinfo_message::has_cid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_sysinfo_message::set_has_cid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_sysinfo_message::clear_has_cid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_sysinfo_message::clear_cid() {
  cid_ = 0;
  clear_has_cid();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::cid() const {
  return cid_;
}
inline void mcb_sysinfo_message::set_cid(::google::protobuf::int32 value) {
  set_has_cid();
  cid_ = value;
}

// optional string name = 3;
inline bool mcb_sysinfo_message::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mcb_sysinfo_message::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mcb_sysinfo_message::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mcb_sysinfo_message::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& mcb_sysinfo_message::name() const {
  return *name_;
}
inline void mcb_sysinfo_message::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_sysinfo_message::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void mcb_sysinfo_message::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_message::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* mcb_sysinfo_message::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_message::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 4;
inline bool mcb_sysinfo_message::has_path() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mcb_sysinfo_message::set_has_path() {
  _has_bits_[0] |= 0x00000008u;
}
inline void mcb_sysinfo_message::clear_has_path() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void mcb_sysinfo_message::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& mcb_sysinfo_message::path() const {
  return *path_;
}
inline void mcb_sysinfo_message::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mcb_sysinfo_message::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mcb_sysinfo_message::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mcb_sysinfo_message::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* mcb_sysinfo_message::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mcb_sysinfo_message::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 oflags = 5;
inline bool mcb_sysinfo_message::has_oflags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mcb_sysinfo_message::set_has_oflags() {
  _has_bits_[0] |= 0x00000010u;
}
inline void mcb_sysinfo_message::clear_has_oflags() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void mcb_sysinfo_message::clear_oflags() {
  oflags_ = 0;
  clear_has_oflags();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::oflags() const {
  return oflags_;
}
inline void mcb_sysinfo_message::set_oflags(::google::protobuf::int32 value) {
  set_has_oflags();
  oflags_ = value;
}

// optional int32 sflags = 6;
inline bool mcb_sysinfo_message::has_sflags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mcb_sysinfo_message::set_has_sflags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void mcb_sysinfo_message::clear_has_sflags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void mcb_sysinfo_message::clear_sflags() {
  sflags_ = 0;
  clear_has_sflags();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::sflags() const {
  return sflags_;
}
inline void mcb_sysinfo_message::set_sflags(::google::protobuf::int32 value) {
  set_has_sflags();
  sflags_ = value;
}

// optional int32 open_nr = 7;
inline bool mcb_sysinfo_message::has_open_nr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mcb_sysinfo_message::set_has_open_nr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void mcb_sysinfo_message::clear_has_open_nr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void mcb_sysinfo_message::clear_open_nr() {
  open_nr_ = 0;
  clear_has_open_nr();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::open_nr() const {
  return open_nr_;
}
inline void mcb_sysinfo_message::set_open_nr(::google::protobuf::int32 value) {
  set_has_open_nr();
  open_nr_ = value;
}

// optional int32 subs_nr = 8;
inline bool mcb_sysinfo_message::has_subs_nr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void mcb_sysinfo_message::set_has_subs_nr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void mcb_sysinfo_message::clear_has_subs_nr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void mcb_sysinfo_message::clear_subs_nr() {
  subs_nr_ = 0;
  clear_has_subs_nr();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::subs_nr() const {
  return subs_nr_;
}
inline void mcb_sysinfo_message::set_subs_nr(::google::protobuf::int32 value) {
  set_has_subs_nr();
  subs_nr_ = value;
}

// optional int32 snd_nr = 9;
inline bool mcb_sysinfo_message::has_snd_nr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void mcb_sysinfo_message::set_has_snd_nr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void mcb_sysinfo_message::clear_has_snd_nr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void mcb_sysinfo_message::clear_snd_nr() {
  snd_nr_ = 0;
  clear_has_snd_nr();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::snd_nr() const {
  return snd_nr_;
}
inline void mcb_sysinfo_message::set_snd_nr(::google::protobuf::int32 value) {
  set_has_snd_nr();
  snd_nr_ = value;
}

// optional int32 rcv_nr = 10;
inline bool mcb_sysinfo_message::has_rcv_nr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void mcb_sysinfo_message::set_has_rcv_nr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void mcb_sysinfo_message::clear_has_rcv_nr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void mcb_sysinfo_message::clear_rcv_nr() {
  rcv_nr_ = 0;
  clear_has_rcv_nr();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::rcv_nr() const {
  return rcv_nr_;
}
inline void mcb_sysinfo_message::set_rcv_nr(::google::protobuf::int32 value) {
  set_has_rcv_nr();
  rcv_nr_ = value;
}

// optional int32 avg_snd = 11;
inline bool mcb_sysinfo_message::has_avg_snd() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void mcb_sysinfo_message::set_has_avg_snd() {
  _has_bits_[0] |= 0x00000400u;
}
inline void mcb_sysinfo_message::clear_has_avg_snd() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void mcb_sysinfo_message::clear_avg_snd() {
  avg_snd_ = 0;
  clear_has_avg_snd();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::avg_snd() const {
  return avg_snd_;
}
inline void mcb_sysinfo_message::set_avg_snd(::google::protobuf::int32 value) {
  set_has_avg_snd();
  avg_snd_ = value;
}

// optional int32 avg_rcv = 12;
inline bool mcb_sysinfo_message::has_avg_rcv() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void mcb_sysinfo_message::set_has_avg_rcv() {
  _has_bits_[0] |= 0x00000800u;
}
inline void mcb_sysinfo_message::clear_has_avg_rcv() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void mcb_sysinfo_message::clear_avg_rcv() {
  avg_rcv_ = 0;
  clear_has_avg_rcv();
}
inline ::google::protobuf::int32 mcb_sysinfo_message::avg_rcv() const {
  return avg_rcv_;
}
inline void mcb_sysinfo_message::set_avg_rcv(::google::protobuf::int32 value) {
  set_has_avg_rcv();
  avg_rcv_ = value;
}

// -------------------------------------------------------------------

// mcb_sysinfo_reply

// required int32 flags = 1;
inline bool mcb_sysinfo_reply::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mcb_sysinfo_reply::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mcb_sysinfo_reply::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mcb_sysinfo_reply::clear_flags() {
  flags_ = 0;
  clear_has_flags();
}
inline ::google::protobuf::int32 mcb_sysinfo_reply::flags() const {
  return flags_;
}
inline void mcb_sysinfo_reply::set_flags(::google::protobuf::int32 value) {
  set_has_flags();
  flags_ = value;
}

// optional .mcb_sysinfo_common common = 2;
inline bool mcb_sysinfo_reply::has_common() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mcb_sysinfo_reply::set_has_common() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mcb_sysinfo_reply::clear_has_common() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mcb_sysinfo_reply::clear_common() {
  if (common_ != NULL) common_->::mcb_sysinfo_common::Clear();
  clear_has_common();
}
inline const ::mcb_sysinfo_common& mcb_sysinfo_reply::common() const {
  return common_ != NULL ? *common_ : *default_instance_->common_;
}
inline ::mcb_sysinfo_common* mcb_sysinfo_reply::mutable_common() {
  set_has_common();
  if (common_ == NULL) common_ = new ::mcb_sysinfo_common;
  return common_;
}
inline ::mcb_sysinfo_common* mcb_sysinfo_reply::release_common() {
  clear_has_common();
  ::mcb_sysinfo_common* temp = common_;
  common_ = NULL;
  return temp;
}
inline void mcb_sysinfo_reply::set_allocated_common(::mcb_sysinfo_common* common) {
  delete common_;
  common_ = common;
  if (common) {
    set_has_common();
  } else {
    clear_has_common();
  }
}

// repeated .mcb_sysinfo_client clients = 3;
inline int mcb_sysinfo_reply::clients_size() const {
  return clients_.size();
}
inline void mcb_sysinfo_reply::clear_clients() {
  clients_.Clear();
}
inline const ::mcb_sysinfo_client& mcb_sysinfo_reply::clients(int index) const {
  return clients_.Get(index);
}
inline ::mcb_sysinfo_client* mcb_sysinfo_reply::mutable_clients(int index) {
  return clients_.Mutable(index);
}
inline ::mcb_sysinfo_client* mcb_sysinfo_reply::add_clients() {
  return clients_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_client >&
mcb_sysinfo_reply::clients() const {
  return clients_;
}
inline ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_client >*
mcb_sysinfo_reply::mutable_clients() {
  return &clients_;
}

// repeated .mcb_sysinfo_message messages = 4;
inline int mcb_sysinfo_reply::messages_size() const {
  return messages_.size();
}
inline void mcb_sysinfo_reply::clear_messages() {
  messages_.Clear();
}
inline const ::mcb_sysinfo_message& mcb_sysinfo_reply::messages(int index) const {
  return messages_.Get(index);
}
inline ::mcb_sysinfo_message* mcb_sysinfo_reply::mutable_messages(int index) {
  return messages_.Mutable(index);
}
inline ::mcb_sysinfo_message* mcb_sysinfo_reply::add_messages() {
  return messages_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_message >&
mcb_sysinfo_reply::messages() const {
  return messages_;
}
inline ::google::protobuf::RepeatedPtrField< ::mcb_sysinfo_message >*
mcb_sysinfo_reply::mutable_messages() {
  return &messages_;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::MCB_SYSINFO_FLAGS>() {
  return ::MCB_SYSINFO_FLAGS_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_mcb_2eproto__INCLUDED
